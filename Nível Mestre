Sistema de Guerra Estratégico - WAR com Missões

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

// Definição da struct Territorio
typedef struct {
    char nome[30];      // Nome do território
    char cor[10];       // Cor do exército que ocupa o território
    int tropas;         // Quantidade de tropas no território
    int id;            // Identificador único do território
} Territorio;

// Definição da struct Missao
typedef struct {
    char descricao[100]; // Descrição da missão
    int tipo;           // 1=Conquistar territórios, 2=Eliminar cor, 3=Conquistar continentes
    char alvo[10];      // Cor alvo (se aplicável)
    int quantidade;     // Quantidade necessária (se aplicável)
} Missao;

// Definição da struct Jogador
typedef struct {
    char nome[30];      // Nome do jogador
    char cor[10];       // Cor do jogador
    Missao* missao;     // Ponteiro para missão do jogador
    int territorios_conquistados; // Contador de territórios conquistados
} Jogador;

// Protótipos de funções
Territorio* alocarTerritorios(int quantidade);
Missao* alocarMissoes(int quantidade);
Jogador* alocarJogadores(int quantidade);
void configurarJogo(Territorio** mapa, Missao** missoes, Jogador** jogadores, 
                   int* num_territorios, int* num_jogadores);
void cadastrarTerritorios(Territorio* mapa, int quantidade);
void atribuirMissoes(Missao* missoes, Jogador* jogadores, int quantidade);
void exibirTerritorios(Territorio* mapa, int quantidade);
void exibirMissoes(Missao* missoes, Jogador* jogadores, int quantidade);
void exibirJogadores(Jogador* jogadores, int quantidade);
void simularAtaque(Territorio* mapa, int num_territorios, Jogador* jogadores);
void atacar(Territorio* atacante, Territorio* defensor);
void verificarVitoria(Territorio* mapa, int num_territorios, Jogador* jogadores, int num_jogadores);
void liberarMemoria(Territorio* mapa, Missao* missoes, Jogador* jogadores);
void limparBuffer();
void pausarTela();
int validarAtaque(Territorio* atacante, Territorio* defensor);
void exibirMenu();

// Variáveis globais
int proximo_id = 1;
int rodada = 1;

// Função principal
int main() {
    srand(time(NULL));  // Inicializa gerador de números aleatórios
    
    Territorio* mapa = NULL;
    Missao* missoes = NULL;
    Jogador* jogadores = NULL;
    int num_territorios = 0;
    int num_jogadores = 0;
    
    printf("=== SISTEMA DE GUERRA ESTRATEGICO - WAR COM MISSOES ===\n\n");
    
    // Configurar o jogo
    configurarJogo(&mapa, &missoes, &jogadores, &num_territorios, &num_jogadores);
    
    if (mapa == NULL || missoes == NULL || jogadores == NULL) {
        printf("Erro na configuracao do jogo!\n");
        return 1;
    }
    
    // Menu principal do jogo
    int opcao;
    int jogo_rodando = 1;
    
    while (jogo_rodando) {
        printf("\n=== RODADA %d ===\n", rodada);
        exibirMenu();
        printf("Escolha uma opcao: ");
        scanf("%d", &opcao);
        limparBuffer();
        
        switch (opcao) {
            case 1:
                printf("\n=== TERRITORIOS ===\n");
                exibirTerritorios(mapa, num_territorios);
                pausarTela();
                break;
                
            case 2:
                printf("\n=== JOGADORES E MISSOES ===\n");
                exibirJogadores(jogadores, num_jogadores);
                exibirMissoes(missoes, jogadores, num_jogadores);
                pausarTela();
                break;
                
            case 3:
                simularAtaque(mapa, num_territorios, jogadores);
                break;
                
            case 4:
                printf("\n=== DISTRIBUIR NOVAS TROPAS ===\n");
                // Distribuir tropas aleatoriamente
                for (int i = 0; i < num_territorios; i++) {
                    int novas_tropas = (rand() % 5) + 1; // 1-5 tropas novas
                    mapa[i].tropas += novas_tropas;
                    printf("%s recebeu +%d tropas (Total: %d)\n", 
                           mapa[i].nome, novas_tropas, mapa[i].tropas);
                }
                rodada++;
                pausarTela();
                break;
                
            case 5:
                verificarVitoria(mapa, num_territorios, jogadores, num_jogadores);
                break;
                
            case 0:
                printf("Encerrando o jogo...\n");
                jogo_rodando = 0;
                break;
                
            default:
                printf("Opcao invalida!\n");
                pausarTela();
        }
    }
    
    // Liberar memória alocada
    liberarMemoria(mapa, missoes, jogadores);
    
    printf("\nJogo finalizado. Ate a proxima!\n");
    return 0;
}

// Função para alocar memória para territórios
Territorio* alocarTerritorios(int quantidade) {
    // Aloca memória dinamicamente para o vetor de territórios
    // Usando calloc para inicializar todos os bytes com zero
    Territorio* vetor = (Territorio*)calloc(quantidade, sizeof(Territorio));
    
    if (vetor == NULL) {
        printf("Erro: nao foi possivel alocar memoria para territorios!\n");
        return NULL;
    }
    
    printf("Alocados %d territorios com sucesso!\n", quantidade);
    return vetor;
}

// Função para alocar memória para missões
Missao* alocarMissoes(int quantidade) {
    // Aloca memória para o vetor de missões
    Missao* vetor = (Missao*)calloc(quantidade, sizeof(Missao));
    
    if (vetor == NULL) {
        printf("Erro: nao foi possivel alocar memoria para missoes!\n");
        return NULL;
    }
    
    printf("Alocados %d missoes com sucesso!\n", quantidade);
    return vetor;
}

// Função para alocar memória para jogadores
Jogador* alocarJogadores(int quantidade) {
    // Aloca memória para o vetor de jogadores
    Jogador* vetor = (Jogador*)calloc(quantidade, sizeof(Jogador));
    
    if (vetor == NULL) {
        printf("Erro: nao foi possivel alocar memoria para jogadores!\n");
        return NULL;
    }
    
    printf("Alocados %d jogadores com sucesso!\n", quantidade);
    return vetor;
}

// Função para configurar o jogo
void configurarJogo(Territorio** mapa, Missao** missoes, Jogador** jogadores, 
                   int* num_territorios, int* num_jogadores) {
    
    printf("=== CONFIGURACAO DO JOGO ===\n\n");
    
    // Configurar número de territórios
    printf("Quantos territorios deseja criar? (min: 6, max: 20): ");
    scanf("%d", num_territorios);
    limparBuffer();
    
    while (*num_territorios < 6 || *num_territorios > 20) {
        printf("Quantidade invalida! Digite entre 6 e 20: ");
        scanf("%d", num_territorios);
        limparBuffer();
    }
    
    // Configurar número de jogadores
    printf("Quantos jogadores vao participar? (min: 2, max: 6): ");
    scanf("%d", num_jogadores);
    limparBuffer();
    
    while (*num_jogadores < 2 || *num_jogadores > 6) {
        printf("Quantidade invalida! Digite entre 2 e 6: ");
        scanf("%d", num_jogadores);
        limparBuffer();
    }
    
    // Alocar memória para todas as estruturas
    *mapa = alocarTerritorios(*num_territorios);
    *missoes = alocarMissoes(*num_jogadores);
    *jogadores = alocarJogadores(*num_jogadores);
    
    if (*mapa == NULL || *missoes == NULL || *jogadores == NULL) {
        printf("Erro na alocacao de memoria!\n");
        return;
    }
    
    // Cadastrar territórios
    cadastrarTerritorios(*mapa, *num_territorios);
    
    // Configurar jogadores
    char cores_disponiveis[6][10] = {"Vermelho", "Azul", "Verde", "Amarelo", "Roxo", "Laranja"};
    
    for (int i = 0; i < *num_jogadores; i++) {
        printf("\n=== JOGADOR %d ===\n", i + 1);
        printf("Nome: ");
        fgets((*jogadores)[i].nome, 30, stdin);
        (*jogadores)[i].nome[strcspn((*jogadores)[i].nome, "\n")] = '\0';
        
        // Atribuir cor automaticamente
        strcpy((*jogadores)[i].cor, cores_disponiveis[i]);
        printf("Cor atribuida: %s\n", (*jogadores)[i].cor);
        
        (*jogadores)[i].territorios_conquistados = 0;
        (*jogadores)[i].missao = NULL; // Será atribuída depois
    }
    
    // Atribuir missões aos jogadores
    atribuirMissoes(*missoes, *jogadores, *num_jogadores);
    
    printf("\n=== CONFIGURACAO CONCLUIDA ===\n");
    printf("Jogo pronto para comecar!\n");
    pausarTela();
}

// Função para cadastrar territórios
void cadastrarTerritorios(Territorio* mapa, int quantidade) {
    printf("\n=== CADASTRO DE TERRITORIOS ===\n");
    
    // Cores disponíveis para distribuição inicial
    char cores[6][10] = {"Vermelho", "Azul", "Verde", "Amarelo", "Roxo", "Laranja"};
    
    for (int i = 0; i < quantidade; i++) {
        mapa[i].id = proximo_id++;
        
        printf("\nTerritorio %d/%d:\n", i + 1, quantidade);
        
        // Nome do território
        printf("Nome: ");
        fgets(mapa[i].nome, 30, stdin);
        mapa[i].nome[strcspn(mapa[i].nome, "\n")] = '\0';
        
        // Atribuir cor aleatoriamente para simular distribuição inicial
        int cor_index = rand() % 6;
        strcpy(mapa[i].cor, cores[cor_index]);
        printf("Cor atribuida aleatoriamente: %s\n", mapa[i].cor);
        
        // Tropas iniciais (entre 5 e 15)
        mapa[i].tropas = (rand() % 11) + 5; // 5-15 tropas
        printf("Tropas iniciais: %d\n", mapa[i].tropas);
    }
}

// Função para atribuir missões aos jogadores
void atribuirMissoes(Missao* missoes, Jogador* jogadores, int quantidade) {
    printf("\n=== ATRIBUINDO MISSOES ===\n");
    
    // Tipos de missões disponíveis
    char* descricoes_tipo1[] = {
        "Conquistar 8 territorios",
        "Conquistar 10 territorios",
        "Conquistar 12 territorios"
    };
    
    char* cores_alvo[] = {"Vermelho", "Azul", "Verde", "Amarelo", "Roxo", "Laranja"};
    
    for (int i = 0; i < quantidade; i++) {
        int tipo_missao = (rand() % 3) + 1; // 1, 2 ou 3
        
        switch (tipo_missao) {
            case 1: // Conquistar territórios
                missoes[i].tipo = 1;
                strcpy(misoes[i].descricao, descricoes_tipo1[rand() % 3]);
                missoes[i].quantidade = 8 + (rand() % 5); // 8-12 territórios
                strcpy(missoes[i].alvo, "");
                break;
                
            case 2: // Eliminar cor
                missoes[i].tipo = 2;
                // Escolher uma cor que não seja a do jogador
                char cor_alvo[10];
                do {
                    strcpy(cor_alvo, cores_alvo[rand() % 6]);
                } while (strcmp(cor_alvo, jogadores[i].cor) == 0);
                
                sprintf(missoes[i].descricao, "Eliminar todos os territorios da cor %s", cor_alvo);
                strcpy(missoes[i].alvo, cor_alvo);
                missoes[i].quantidade = 0;
                break;
                
            case 3: // Conquistar territórios específicos
                missoes[i].tipo = 3;
                sprintf(missoes[i].descricao, "Conquistar 15 territorios com pelo menos 10 tropas cada");
                missoes[i].quantidade = 15;
                strcpy(missoes[i].alvo, "");
                break;
        }
        
        // Atribuir missão ao jogador
        jogadores[i].missao = &missoes[i];
        
        printf("Jogador %s (%s) recebeu a missao: %s\n", 
               jogadores[i].nome, jogadores[i].cor, missoes[i].descricao);
    }
}

// Função para exibir territórios
void exibirTerritorios(Territorio* mapa, int quantidade) {
    if (quantidade == 0) {
        printf("Nenhum territorio cadastrado!\n");
        return;
    }
    
    printf("\n=== MAPA DE TERRITORIOS ===\n");
    printf("ID  | NOME                | COR      | TROPAS\n");
    printf("----|---------------------|----------|--------\n");
    
    for (int i = 0; i < quantidade; i++) {
        printf("%-3d | %-20s | %-8s | %-6d\n", 
               mapa[i].id, 
               mapa[i].nome, 
               mapa[i].cor, 
               mapa[i].tropas);
    }
}

// Função para exibir missões
void exibirMissoes(Missao* missoes, Jogador* jogadores, int quantidade) {
    printf("\n=== MISSOES DOS JOGADORES ===\n");
    
    for (int i = 0; i < quantidade; i++) {
        printf("\nJogador: %s (%s)\n", jogadores[i].nome, jogadores[i].cor);
        printf("Missao: %s\n", jogadores[i].missao->descricao);
        printf("Territorios conquistados: %d\n", jogadores[i].territorios_conquistados);
    }
}

// Função para exibir jogadores
void exibirJogadores(Jogador* jogadores, int quantidade) {
    printf("\n=== JOGADORES ===\n");
    
    for (int i = 0; i < quantidade; i++) {
        printf("%d. %s - Cor: %s\n", 
               i + 1, jogadores[i].nome, jogadores[i].cor);
    }
}

// Função para validar se um ataque é permitido
int validarAtaque(Territorio* atacante, Territorio* defensor) {
    // Um ataque só é válido se as cores forem diferentes
    return (strcmp(atacante->cor, defensor->cor) != 0);
}

// Função para simular um ataque entre dois territórios
void atacar(Territorio* atacante, Territorio* defensor) {
    printf("\n=== SIMULACAO DE ATAQUE ===\n");
    printf("ATACANTE: %s (%s) - %d tropas\n", 
           atacante->nome, atacante->cor, atacante->tropas);
    printf("DEFENSOR: %s (%s) - %d tropas\n", 
           defensor->nome, defensor->cor, defensor->tropas);
    printf("\n");
    
    // Verificar se o atacante tem tropas suficientes
    if (atacante->tropas < 2) {
        printf("Ataque impossivel! Atacante precisa de pelo menos 2 tropas.\n");
        return;
    }
    
    // Lançar dados para atacante e defensor
    int dado_atacante = (rand() % 6) + 1;  // Número entre 1 e 6
    int dado_defensor = (rand() % 6) + 1;  // Número entre 1 e 6
    
    printf("Dado do ATACANTE: %d\n", dado_atacante);
    printf("Dado do DEFENSOR: %d\n", dado_defensor);
    printf("\n");
    
    // Determinar resultado do ataque
    if (dado_atacante > dado_defensor) {
        // ATACANTE VENCEU
        printf("*** VITORIA DO ATACANTE! ***\n");
        
        // Calcular tropas conquistadas (metade das tropas do defensor)
        int tropas_conquistadas = defensor->tropas / 2;
        if (tropas_conquistadas < 1) tropas_conquistadas = 1;
        
        // Transferir cor e tropas
        printf("%s conquista %s!\n", atacante->nome, defensor->nome);
        printf("Cor alterada de '%s' para '%s'\n", defensor->cor, atacante->cor);
        printf("Tropas transferidas: %d\n", tropas_conquistadas);
        
        // Atualizar dados do defensor
        strcpy(defensor->cor, atacante->cor);
        defensor->tropas = tropas_conquistadas;
        
        // Atacante perde 1 tropa no ataque
        atacante->tropas--;
        printf("Atacante perde 1 tropa no ataque. Restam: %d tropas\n", atacante->tropas);
        
    } else if (dado_atacante < dado_defensor) {
        // DEFENSOR VENCEU
        printf("*** VITORIA DO DEFENSOR! ***\n");
        
        // Atacante perde 1 tropa
        atacante->tropas--;
        printf("Atacante perde 1 tropa. Restam: %d tropas\n", atacante->tropas);
        
        // Defensor mantém seu território
        printf("Defensor mantem o territorio %s\n", defensor->nome);
        
    } else {
        // EMPATE
        printf("*** EMPATE! ***\n");
        printf("Nenhuma alteracao nos territorios.\n");
    }
    
    printf("\n=== SITUACAO ATUAL ===\n");
    printf("ATACANTE %s: %d tropas\n", atacante->nome, atacante->tropas);
    printf("DEFENSOR %s: %d tropas (%s)\n", defensor->nome, defensor->tropas, defensor->cor);
}

// Função para simular um ataque (interface com usuário)
void simularAtaque(Territorio* mapa, int num_territorios, Jogador* jogadores) {
    if (num_territorios < 2) {
        printf("Eh necessario pelo menos 2 territorios para simular ataque!\n");
        return;
    }
    
    printf("\n=== SIMULAR ATAQUE ===\n");
    exibirTerritorios(mapa, num_territorios);
    
    int id_atacante, id_defensor;
    
    printf("\nEscolha o territorio ATACANTE (ID): ");
    scanf("%d", &id_atacante);
    limparBuffer();
    
    printf("Escolha o territorio DEFENSOR (ID): ");
    scanf("%d", &id_defensor);
    limparBuffer();
    
    // Validar IDs
    if (id_atacante < 1 || id_atacante > num_territorios ||
        id_defensor < 1 || id_defensor > num_territorios) {
        printf("IDs invalidos!\n");
        return;
    }
    
    if (id_atacante == id_defensor) {
        printf("Nao pode atacar o proprio territorio!\n");
        return;
    }
    
    Territorio* atacante = &mapa[id_atacante - 1];
    Territorio* defensor = &mapa[id_defensor - 1];
    
    if (validarAtaque(atacante, defensor)) {
        atacar(atacante, defensor);
        
        // Atualizar contagem de territórios conquistados
        // (Em um jogo completo, isso seria mais complexo)
        
    } else {
        printf("Ataque invalido! Territorios tem a mesma cor (%s).\n", atacante->cor);
    }
    
    pausarTela();
}

// Função para verificar condições de vitória
void verificarVitoria(Territorio* mapa, int num_territorios, Jogador* jogadores, int num_jogadores) {
    printf("\n=== VERIFICANDO CONDICOES DE VITORIA ===\n");
    
    // Contar territórios por cor
    int contagem_cores[6] = {0}; // Supondo 6 cores diferentes
    char* cores[6] = {"Vermelho", "Azul", "Verde", "Amarelo", "Roxo", "Laranja"};
    
    for (int i = 0; i < num_territorios; i++) {
        for (int j = 0; j < 6; j++) {
            if (strcmp(mapa[i].cor, cores[j]) == 0) {
                contagem_cores[j]++;
                break;
            }
        }
    }
    
    // Verificar se algum jogador completou sua missão
    for (int i = 0; i < num_jogadores; i++) {
        int missao_completa = 0;
        Missao* m = jogadores[i].missao;
        
        switch (m->tipo) {
            case 1: // Conquistar X territórios
                // Em um jogo completo, teríamos que rastrear quais territórios cada jogador possui
                printf("Missao de %s: Conquistar %d territorios (progresso: ?/?)\n", 
                       jogadores[i].nome, m->quantidade);
                break;
                
            case 2: // Eliminar cor
                // Verificar se a cor alvo ainda existe
                int cor_existe = 0;
                for (int j = 0; j < num_territorios; j++) {
                    if (strcmp(mapa[j].cor, m->alvo) == 0) {
                        cor_existe = 1;
                        break;
                    }
                }
                if (!cor_existe) {
                    missao_completa = 1;
                }
                printf("Missao de %s: Eliminar cor %s (%s)\n", 
                       jogadores[i].nome, m->alvo, cor_existe ? "Pendente" : "COMPLETA!");
                break;
                
            case 3: // Conquistar territórios específicos
                printf("Missao de %s: %s (progresso: ?/?)\n", 
                       jogadores[i].nome, m->descricao);
                break;
        }
        
        if (missao_completa) {
            printf("\n*** PARABENS! %s COMPLETOU SUA MISSAO E VENCEU O JOGO! ***\n", 
                   jogadores[i].nome);
            printf("Missao: %s\n", m->descricao);
            return;
        }
    }
    
    printf("\nNenhum jogador completou sua missao ainda. Continue jogando!\n");
    pausarTela();
}

// Função para liberar toda a memória alocada
void liberarMemoria(Territorio* mapa, Missao* missoes, Jogador* jogadores) {
    printf("\n=== LIBERANDO MEMORIA ===\n");
    
    // Liberar memória dos territórios
    if (mapa != NULL) {
        free(mapa);
        printf("Memoria dos territorios liberada.\n");
    }
    
    // Liberar memória das missões
    if (missoes != NULL) {
        free(missoes);
        printf("Memoria das missoes liberada.\n");
    }
    
    // Liberar memória dos jogadores
    if (jogadores != NULL) {
        free(jogadores);
        printf("Memoria dos jogadores liberada.\n");
    }
    
    printf("Toda memoria foi liberada com sucesso!\n");
}

// Função para limpar o buffer de entrada
void limparBuffer() {
    int c;
    while ((c = getchar()) != '\n' && c != EOF);
}

// Função para pausar a tela
void pausarTela() {
    printf("\nPressione Enter para continuar...");
    getchar();
}

// Função para exibir o menu principal
void exibirMenu() {
    printf("\n=== MENU PRINCIPAL ===\n");
    printf("1. Exibir mapa de territorios\n");
    printf("2. Exibir jogadores e missoes\n");
    printf("3. Simular ataque entre territorios\n");
    printf("4. Avancar rodada (distribuir tropas)\n");
    printf("5. Verificar condicoes de vitoria\n");
    printf("0. Sair do jogo\n");
}
```

Características Principais do Sistema:

1. Alocação Dinâmica Completa

```c
Territorio* alocarTerritorios(int quantidade);
Missao* alocarMissoes(int quantidade);
Jogador* alocarJogadores(int quantidade);
```

· Usa calloc para alocar memória para todas as estruturas
· Verifica se a alocação foi bem-sucedida
· Permite tamanhos variáveis de jogo

2. Sistema de Missões Estratégicas

```c
typedef struct {
    char descricao[100];
    int tipo; // 1, 2 ou 3
    char alvo[10];
    int quantidade;
} Missao;
```

· Três tipos de missões diferentes
· Missões são atribuídas aleatoriamente aos jogadores
· Sistema de verificação de vitória baseado em missões

3. Função de Ataque Avançada

```c
void atacar(Territorio* atacante, Territorio* defensor) {
    int dado_atacante = (rand() % 6) + 1;
    int dado_defensor = (rand() % 6) + 1;
    
    if (dado_atacante > dado_defensor) {
        // Conquista: transfere cor e metade das tropas
        strcpy(defensor->cor, atacante->cor);
        defensor->tropas = defensor->tropas / 2;
        atacante->tropas--;
    }
    // ...
}
```

· Implementa todas as regras solicitadas
· Usa rand() com srand(time(NULL)) para aleatoriedade
· Valida ataques entre cores iguais

4. Gestão Completa de Memória

```c
void liberarMemoria(Territorio* mapa, Missao* missoes, Jogador* jogadores) {
    if (mapa != NULL) free(mapa);
    if (missoes != NULL) free(missoes);
    if (jogadores != NULL) free(jogadores);
}
```

· Libera todas as estruturas alocadas dinamicamente
· Verifica ponteiros antes de liberar
· Evita vazamentos de memória

5. Interface de Usuário Amigável

· Menu interativo com múltiplas opções
· Exibição formatada de dados
· Sistema de rodadas e progressão do jogo

Como Compilar e Executar:

```bash
# Compilar o programa
gcc -o war_completo war_completo.c

# Executar o programa
./war_completo
```

Exemplo de Execução:

```
=== SISTEMA DE GUERRA ESTRATEGICO - WAR COM MISSOES ===

=== CONFIGURACAO DO JOGO ===

Quantos territorios deseja criar? (min: 6, max: 20): 8
Quantos jogadores vao participar? (min: 2, max: 6): 3

Alocados 8 territorios com sucesso!
Alocados 3 missoes com sucesso!
Alocados 3 jogadores com sucesso!

=== CADASTRO DE TERRITORIOS ===

Territorio 1/8:
Nome: Brasil
Cor atribuida aleatoriamente: Vermelho
Tropas iniciais: 12

... (mais territórios)

=== JOGADOR 1 ===
Nome: Alice
Cor atribuida: Vermelho

=== JOGADOR 2 ===
Nome: Bob
Cor atribuida: Azul

=== JOGADOR 3 ===
Nome: Carlos
Cor atribuida: Verde

=== ATRIBUINDO MISSOES ===
Jogador Alice (Vermelho) recebeu a missao: Conquistar 10 territorios
Jogador Bob (Azul) recebeu a missao: Eliminar todos os territorios da cor Verde
Jogador Carlos (Verde) recebeu a missao: Conquistar 15 territorios com pelo menos 10 tropas cada

=== RODADA 1 ===
=== MENU PRINCIPAL ===
1. Exibir mapa de territorios
2. Exibir jogadores e missoes
3. Simular ataque entre territorios
4. Avancar rodada (distribuir tropas)
5. Verificar condicoes de vitoria
0. Sair do jogo
Escolha uma opcao: 3

=== SIMULAR ATAQUE ===
=== MAPA DE TERRITORIOS ===
ID  | NOME                | COR      | TROPAS
----|---------------------|----------|--------
1   | Brasil              | Vermelho | 12
2   | Argentina           | Azul     | 15
3   | Chile               | Verde    | 10
...

Escolha o territorio ATACANTE (ID): 1
Escolha o territorio DEFENSOR (ID): 3

=== SIMULACAO DE ATAQUE ===
ATACANTE: Brasil (Vermelho) - 12 tropas
DEFENSOR: Chile (Verde) - 10 tropas

Dado do ATACANTE: 5
Dado do DEFENSOR: 2

*** VITORIA DO ATACANTE! ***
Brasil conquista Chile!
Cor alterada de 'Verde' para 'Vermelho'
Tropas transferidas: 5
Atacante perde 1 tropa no ataque. Restam: 11 tropas
